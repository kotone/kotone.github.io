<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[按照条件过滤数组]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%95%B0%E7%BB%84%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[好久没写东西了，没有绿点的 github , 不是我想要的青青草原。 最近项目需要对数组进行过滤，比如脑补一个商品列表：123456var arr = [ &#123;id: 0, size: 'S', tag: '推荐'&#125;, &#123;id: 1, size: 'S', tag: '精品'&#125;, &#123;id: 2, size: 'M', tag: '特价'&#125;, &#123;id: 3, size: 'L', tag: '推荐'&#125;] 筛选出所有推荐商品 , emmm , 我就直接写Es6方法吧 123456const filterTag = (array, key, target) =&gt; &#123; return array.filter(item =&gt; item[key] === target )&#125;// 测试filterTag(arr, 'tag', '推荐') 上面是tag只有一个的情况，实际上商品可能有很多不同的标签 , 比如123456var arr = [ &#123;id: 0, size: 'S', tag: ['推荐', '黑色']&#125;, &#123;id: 1, size: 'S', tag: ['精品', '白色']&#125;, &#123;id: 2, size: 'M', tag: ['特价','白色']&#125;, &#123;id: 3, size: 'L', tag: '推荐'&#125;] tag有的是数组，有的是字符串，过滤的时候需要判断下 tag的类型12345678const filterSingleTag = (array, key, tag) =&gt; &#123; return array.filter((items) =&gt; &#123; return Array.isArray(items[key]) ? items[key].some(item =&gt; item === tag) : items[key] === tag &#125;)&#125;// 测试filterSingleTag(arr, 'tag', '推荐') emmm…要是我想要 精品并且白色的商品呢？这个….需求可以实现：上一个函数用到了some方法, some 是一个或 的关系，存在就返回true, 这次我们需要一个且关系 every, 只有都满足的情况才返回 true12345678910const filterMultipleTag = (array, key, tags) =&gt; &#123; if (!Array.isArray(tags)) throw Error('tags arguments must array') return array.filter(item =&gt; &#123; return tags.every(tag =&gt; item[key].indexOf(tag) !== -1) &#125;)&#125;// 测试filterMultipleTag(arr, 'tag', ['精品', '白色'])// ps 这个方法可以干掉上面的 filterSingleTag 现在，要是需求变为要筛选出 size 为 S, 并且 tag 为 白色的商品呢？123456789101112131415// options 为 过滤的条件，如果不是对象就报错const filterOptionsTag = (array, options) =&gt; &#123; if (Object.prototype.toString.call(options).slice(8, -1) !== 'Object') throw Error('options must be Object') let keys = Object.keys(options) return array.filter(item =&gt; &#123; return keys.every(key =&gt; item[key].indexOf(options[key]) !== -1) &#125;)&#125;// 测试let options = &#123; size: 'S', tag: '白色'&#125;filterOptionsTag(arr, options) 就先写道这里吧。感谢你的阅读。如果有更好的方法或者文中 有什么错误还望指出 Email : 1581850039@qq.com]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数组过滤</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端复习笔记-2]]></title>
    <url>%2F2018%2F09%2F02%2F%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[本篇主要对 基础 进行复习总结 ( 缓更 ) 词法作用域 文章链接 https://github.com/mqyqingfeng/Blog/issues/3 JavaScript是采用词法作用域的，这就意味着函数的执行依赖于函数定义的时候所产生（而不是函数调用的时候产生的）的变量作用域 理解这个后下面这些例子也就很快想明白了：1234567891011121314var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果 为 1 // 先执行 bar() , 在执行 foo() , foo() 函数定义在最外层, 所以会输出最外层的 value 值 《JavaScript权威指南》中的例子:12345678910var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f;&#125;checkscope()();// 先执行 checkscope() , 返回 f, 然后执行 f(), f() 定义在 checkscope()内部且其内部有scope 变量, 所以结果 为 local scope 12345678910var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f();&#125;checkscope();// 执行 checkscope(), 然后执行 f() , f() 定义在 checkscope()内部且其内部有scope 变量, 所以结果 为 local scope 评论中的例子：12345678var value = 1;var f = function() &#123; console.log(value) &#125;function out(f) &#123; var value = 2; f();&#125;out(f)// 执行 out(f), 然后执行f(), f() 定义的位置在最外层，所以输出结果为 最外层的 1 变量提升/函数提升 原文：https://github.com/mqyqingfeng/Blog/issues/4https://github.com/mqyqingfeng/Blog/issues/5 文章讲了函数执行上下文栈，变量对象。 除了看文章，评论也十分精彩。下面是原文的两段代码：12345678910var foo = function () &#123; console.log('foo1');&#125;foo(); // foo1var foo = function () &#123; console.log('foo2');&#125;foo(); // foo2 1234567891011function foo() &#123; console.log('foo1');&#125;foo(); // foo2function foo() &#123; console.log('foo2');&#125;foo(); // foo2 这两段代码涉及到函数提升以及变量提升，将他们改成函数提升/变量提升后的结果为：12345678910111213// 第一段var foo;foo = function() &#123; console.log('foo1')&#125;foo() // foo1foo = function() &#123; console.log('foo2')&#125;foo() //foo2 123456789// 第二段function foo() &#123; console.log('foo1')&#125;function foo() &#123; console.log('foo2')&#125;foo() // foo2foo() // foo2 第一段代码是变量提升，第二段代码是函数提升评论中的例子：12345// 函数声明可以提升foo(); // foofunction foo() &#123; console.log('foo');&#125; 1234567891011// 函数表达式不会提升 ，提升的是 变量 foofoo(); // TypeError: undefined is not a functionvar foo = function() &#123; console.log('foo');&#125;// 提升后的代码var foo;foo() // TypeError: undefined is not a functionfoo = function() &#123; console.log('foo')&#125; 关于函数提升和变量提升优先级问题：1234567891011121314console.log(foo);function foo()&#123; console.log("foo");&#125;var foo = 1;// 打印 函数 而不是 undefined// 变量提升之后function foo() &#123;console.log('foo')&#125;; // 函数提升var foo; // 变量名称和函数名重复了，被忽略console.log(foo) // 打印 foo() 函数foo = 1 // foo 赋值为 1console.log(foo()) // 报错 foo() 已被赋值为 1 下面是评论中的带形参的例子：1234567function fun(a)&#123; var a; console.log(a); a = 2;&#125;fun(1); // 打印 1 fun存在变量 a , 为什么结果不是 undefined,而是形参呢？在看下第二种情况 , fun 内部有同名函数时：123456789function fun(a)&#123; var a; console.log(a); function a()&#123; console.log('a') &#125; a = 2;&#125;fun(1); // 打印 a() 结果打印的是函数，说明函数提升了,而且替换了形参。变换后的代码如下：1234567function fun(a) &#123; function a()&#123;console.log('a')&#125;; // 函数提升 var a; // 变量名称和函数名重复了，被忽略 console.log(a) a = 2&#125;fun(1) // 打印 a() 看了两种情况，最大的问题时形参和变量提升，函数提升有什么关系？判断的方式为： 分析形参，值为1 分析函数，不存在，则不替换 分析变量，已经存在，不修改 最后针对变量提升总结为 变量申明和函数申明(整体)会被提升，函数表达式提升的是申明变量，函数本身不提升; 首先会处理函数声明，其次会处理变量声明，如果 变量名称 跟 已经声明 的 形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 另外评论中还有一道关于引用指向问题：12345var a = &#123; n: 1 &#125;;var b = a;a.x = a = &#123; n: 2 &#125;;console.log(a); // &#123;n:2&#125;console.log(b); // &#123;n:1, x: &#123;n:2&#125;&#125; 前两步 a , b 都指向 同一个对象 {n: 1} a.x = a = {n: 2} 点运算符优先级最高 a.x 相当于 {n:1}.x , 连等从右往左, a = {n: 2} , {n: 1}.x = {n: 2} 。a 的指向变成了新对象 {n: 2}, 对象 {n: 1} 增加了 x 属性。 b 一直指向对象{n: 1} this 指向 原文 https://github.com/mqyqingfeng/Blog/issues/7 博客大佬是从规范来解答 this 指向的。其实我更喜欢评论中的总结（捂脸）:this 一般的几种调用场景：var obj = {a: 1, b: function(){console.log(this);}} 作为对象调用时，指向该对象 obj.b(); // 指向 obj 作为函数调用, var b = obj.b; b() ; // 指向全局 window 作为构造函数调用 var b = new Fun() ; // this 指向当前实例对象 作为 call 与 apply 调用 obj.b.apply(object, []) ; // this 指向当前的 object 感觉 this判断 和 词法作用域 判断会有点混淆（捂脸） HTTP / TCPHttp协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接 1. TCP建立连接（三次握手）： 第一次握手 : 客户机 A 发送标识位 SYN = 1 , 随机产生序列号seq = x 的数据包到服务器 B , 服务器 B 由 SYN = 1 知道客户机 A 要建立连接 ，并进入 SYN_SEND 状态 ，等待服务器确认 第二次握手 : 服务器 B 收到请求并确认联机信息后 , 向客户机 A 发送标识位 SYN = 1 , ACK = 1 和随机产生的序列号 seq = y , 确认码 ack = x + 1（客户机 A 发送的 seq + 1）的数据包，此时服务器进入SYN_RECV 状态 第三次握手 : 客户机 A 收到后检查确认码 ack 是否正确 , 即和第一次握手发送的序列号 加 1 结果是否相等，以及 ACK 标识位是否为 1；若正确，客户机 A 发送标识位 ACK = 1、seq = x + 1 和确认码 ack = y + 1（服务器B发送的seq + 1）到服务器B，服务器B收到后确认 ACK = 1 和 seq 是否正确，若正确则完成建立连接，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手，客户端与服务器开始传送数据。 断开连接（ TCP的四次挥手）: 第一次挥手 ：客户端A发送一个FIN = 1、初始化序列号seq = u，到服务器B，用来主动关闭客户A到服务器B的数据传送，客户机A进入FIN-WAIT-1状态，等待服务器B发送FIN； 第二次挥手 ：服务器B收到这个FIN，它发回ACK = 1、确认序号 ack 为收到的序号加1（ack = u+1）；和SYN一样，一个FIN将占用一个序号seq = v，客户机A进入FIN-WAIT-2，稍后关闭连接，服务器B进入CLOSE_WAIT，等待关闭连接; 第三次挥手 ：服务器B关闭与客户端A的连接，发回标识位FIN = 1，ACK = 1,seq = w和确认码ack = u+1给客户端A，服务器B进入LAST_ACK，等待最后一次ACK确认; 第四次挥手 ：客户端A发送ACK = 1报文确认，并将确认序号设置为收到序号加1（ack = w+1）到服务器B，客户机A进入TIME-WAIT等待2MAL后进入CLOSE可用状态，服务器B进入CLOSE可用状态。 由于TCP连接是 全双工 的，因此每个方向都必须单独进行关闭 ( 发送方和接收方都需要 FIN 和 ACK ) , 这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序及wepy使用-总结篇]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%B0%8F%E7%A8%8B%E5%BA%8Fwepy%2F</url>
    <content type="text"><![CDATA[微信小程序及wepy使用-总结篇(不定期更新) 总结一些自己在开发小程序时觉得很有用，或者踩过的坑 promise 封装小程序 api 中有很多异步函数,比如 request、login....，在处理微信登陆、微信授权…等会出现大量回调,影响代码的可读性。所以可以将内置的异步函数封装成 promise 。1234567891011121314151617export const promisify = fn =&gt; &#123; return (obj = &#123;&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; obj.success = function (res) &#123; resolve(res) &#125; obj.fail = function (res) &#123; reject(res) &#125; fn(obj) &#125;) &#125;&#125;// 使用const wxRequestPromise = promisify(wx.request)wxRequestPromise().then(res =&gt; console.log(res)) 如果是使用 wepy 只需要开启 promise 就可以直接使用 promise 了1wepy.request().then(res =&gt; &#123;console.log(res)&#125;) wepy 拦截器wepy 提供了 intercept 全局拦截器，可以对原生API的请求进行拦截例如我们需要在给所有的请求添加自定义 header 头:12345678910// 拦截器this.intercept('request', &#123; config (p) &#123; p.header = &#123;'version': '3.0', 'XX-Token': token&#125; return p &#125;, success (p) &#123; return p &#125;&#125;) 这样所有的请求都会带上自定义的 header 头去请求。还可以对请求结果进行处理，具体看情况了。 小程序授权针对授权，个人的处理方式是： 首先写一个模拟弹窗子组件，这个弹窗主要是用于用户拒绝了某授权后弹出的,弹窗信息作为参数,按钮为打开 opensetting 系统组件。 如果是进入首屏就需要用户授权的，可以写一个覆盖整个屏幕透明的授权按钮，检测用户授权后再隐藏按钮。 友好型授权，需要用户授权的时候才弹出授权，配合模拟弹窗子组件使用，判断用户授权状态。 web-view使用 引入移动端调试工具。比如 eruda 。真机预览才能看到写的 bug 。 如果要在 web-view 页面使用图片上传等功能, input file 在chrome 调试是完全没问题。可以是放到我们小程序页面，ios10 会出现小程序闪退，而ios11 则正常（安卓未作测试）。解决办法就是使用微信js-sdk。(2018-7) 向 web-view 传递参数时需要注意对带有中文，以及特殊符号的进行encodeURIComponent 编码处理 js-sdk调用 js-sdk 的 getLocalImgData 方法需要注意的： iOS 系统里面得到的数据，类型为 image/jgp , 需要替换下 1localData = localData.replace('jgp', 'jpeg'); 安卓系统得到的数据，是没有 data:image/jpeg;base64 前缀的 使用 window.__wxjs_is_wkwebview 可以判断当前设备类型。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>wepy</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas绘制GIF]]></title>
    <url>%2F2018%2F08%2F05%2Fcanvas%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[ps: 歌曲有毒这周实现一个和 canvas 动画，目标就是给出一个 GIF,然后在页面使用 canvas 绘制出来。实现思路大致为将 GIF每帧保存为一张图片，然后使用canvas绘制每帧 “分解” GIF首先第一步就是得到 GIF 的每帧的图片,我这里使用的是 python3,另外 github 有个绘制 GIF 的js 库贴上 python3 代码：1234567891011121314151617import os# python3 =&gt; pip install Pillowfrom PIL import Imagedef main(gif_file): png_dir = gif_file[:-4] + '/' os.mkdir(png_dir) img = Image.open(gif_file) try: while True: current = img.tell() img.save(png_dir+str(current)+'.png') img.seek(current+1) except: passmain('nico.gif') canvas绘制经过上面的处理，得到了gif每帧的图片(图片数量由gif帧数决定),接下来，将图片绘制在canvas中1234567891011121314151617181920212223242526272829303132333435363738var DrawGif = function(imgArr,fps,width,height) &#123; this.startFrame = 0; //开始帧 this.endFrame = imgArr.length-1; //结束帧 this.width = width; this.height = height; this.imgArr = imgArr; this.fps = fps; this.frameRate = 1000/this.fps;&#125;DrawGif.prototype = &#123; init: function() &#123; var canvas = this.canvas = document.createElement('canvas'); canvas.width = this.width; canvas.height = this.height; this.ctx = canvas.getContext("2d"); this.imgObj = []; for(var k in this.imgArr)&#123; var img = new Image(); img.src = this.imgArr[k]; this.imgObj.push(img); &#125; this.endFrame = this.imgObj.length - 1; return this &#125;, play: function(Callback) &#123; this.init() var canvas = this.canvas var self = this; this.tiemer = setInterval(function() &#123; self.startFrame &lt; self.endFrame ? self.startFrame++ : self.startFrame = 0 self.ctx.clearRect(0,0,self.width,self.height); self.ctx.drawImage(self.imgObj[self.startFrame], 0, 0,self.width,self.height); &#125;,this.frameRate) Callback(canvas); &#125;&#125; 再调用上面的函数：12345678910// 图片路径var img_arr = []for (var i = 0; i &lt; 22; i++) &#123; img_arr.push('./img/nico/' + i + '.png')&#125;// 调用函数var gif = new DrawGif(img_arr, 12, 300, 300)gif.play(function(canvas)&#123; document.body.appendChild(canvas)&#125;); 效果图如下： 完善添加函数功能上面的函数只能无限循环,现在让gif只播放一次,以及支持结束后的回调123456789101112131415161718192021222324252627...// 修改下play 函数play: function(options,Callback) &#123; this.init() var loop = options.loop || false; // 循环 var isComplete = options.isComplete || function() &#123;&#125;; // 完成后的回调 var canvas = this.canvas; var self = this; this.tiemer = setInterval(function() &#123; var end = self.startFrame &lt; self.endFrame if (loop) &#123; end ? self.startFrame++ : self.startFrame = 0 &#125; else &#123; end ? self.startFrame++ : self.stop() &amp;&amp; isComplete(); &#125; self.ctx.clearRect(0, 0, self.width, self.height); self.ctx.drawImage(self.imgObj[self.startFrame], 0, 0, self.width, self.height); &#125;, this.frameRate) Callback(canvas);&#125;,// 添加 stop 函数stop: function() &#123; clearInterval(this.tiemer); return this&#125; 调用部分变更为：1234567891011...// 调用函数var gif = new DrawGif(img_arr, 12, 300, 300)gif.play(&#123; loop: false, // 不循环 isComplete: function()&#123; console.log('niconiconi') // 结束执行函数 &#125;&#125;,function(canvas)&#123; document.body.appendChild(canvas)&#125;); 完整代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var DrawGif = function(imgArr, fps, width, height) &#123; this.startFrame = 0; //开始帧 this.endFrame = imgArr.length-1; //结束帧 this.width = width; this.height = height; this.imgArr = imgArr; this.fps = fps; this.frameRate = 1000 / this.fps;&#125;DrawGif.prototype = &#123; init: function() &#123; var canvas = this.canvas = document.createElement('canvas'); canvas.width = this.width; canvas.height = this.height; this.ctx = canvas.getContext("2d"); this.imgObj = []; for(var k in this.imgArr)&#123; var img = new Image(); img.src = this.imgArr[k]; this.imgObj.push(img); &#125; this.endFrame = this.imgObj.length - 1; return this &#125;, play: function(options, Callback) &#123; this.init() var loop = options.loop || false; // 循环 var isComplete = options.isComplete || function() &#123;&#125;; // 完成后的回调 var canvas = this.canvas var self = this; this.tiemer = setInterval(function() &#123; var end = self.startFrame &lt; self.endFrame if (loop) &#123; end ? self.startFrame++ : self.startFrame = 0 &#125; else &#123; end ? self.startFrame++ : self.stop() &amp;&amp; isComplete() &#125; self.ctx.clearRect(0,0,self.width, self.height); self.ctx.drawImage(self.imgObj[self.startFrame], 0, 0, self.width, self.height); &#125;, this.frameRate) Callback(canvas); &#125;, stop: function() &#123; clearInterval(this.tiemer); return this &#125;&#125;// 调用部分var gif = new DrawGif(img_arr, 12, 300, 300)gif.play(&#123; loop: false, isComplete: function() &#123; console.log('niconiconi') &#125;&#125;,function(canvas)&#123; document.body.appendChild(canvas)&#125;); 改进的地方 如果play函数没有传options参数，会导致报错。需要对函数参数进行判断。 构造函数是否有更优化？(总觉得还可以优化)]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用charles和python3获取游戏客户端资源]]></title>
    <url>%2F2018%2F07%2F29%2F%E6%8A%93%E5%8C%85%E8%8E%B7%E5%8F%96%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[周末玩乖离的时候，突发奇想，想要把所有的卡牌都保存下来。说干就干。使用charles连接设备，抓包获得图片请求地址，使用python3下载图片。整个过程并不复杂，但自己最开始思路错了，以至于花了很长时间……. 最开始的思路最开始我的思路是抓取游戏中图鉴的第一张图片地址(chr51_10001009.png)，再抓取最后一张(chr51_12000899.png)，这样就产生了一个范围。然后就是循环这个范围下载。启动下载后才发现。很多地址都是404,而且这两个地址之间的范围太大了。而客户端卡牌总数才940,加上要获得卡牌还需要代理(被墙),导致想要快速，准确下载完所有卡牌变得不可能。 换个思路换个思路，既然卡牌图片是请求服务器获取到的，客户端卡牌图鉴渲染所有的卡牌就应该有对应的json，所以只要抓取到这个请求的数据，就能准确的知道卡牌对应的地址了。打开客户端的卡牌图鉴页面抓包 可以看出，这是一个post请求，参数是一串加密的字符串（应该是客户端产生的，这个字符串每隔一分钟会更新，有一个Ping的post接口通知服务器）。返回的数据虽然不是标准的一个json，但是包含了我们需要的卡牌图片地址(cardid字段),下面开始通过python获取这个数据12345678910111213141516171819import requests # 需要安装 requests,最好设置代理安装 pip install requests --proxy 127.0.0.1:1080# 接口地址postUrl = '******/Game/CardCollectionShow'# 代理访问(墙)proxies=&#123; 'http':'127.0.0.1:1080', 'https':'127.0.0.1:1080'&#125;# 设置请求头,和客户端一致headers = &#123; 'content-type': 'application/x-www-form-urlencoded', 'User-Agent': 'man/7.0.3 CFNetwork/897.15 Darwin/17.5.0'&#125;# post 参数post_data = '1CL4Jp6izQ8qumA3oQW0UFc3FFrfw=' #每隔一分钟会更新,抓包获取r = requests.post(postUrl,data=post_data,proxies=proxies,headers=headers)print(r.text) 请求结果虽然不是一个json，但是并没有太大影响，我们可以使用正则re.findall(r&#39;cardid&quot;:(\d+)&#39;,r.text)获取到地址。最后就是拼接url，下载了。贴上自己的完整代码：123456789101112131415161718192021222324252627282930313233import requestsimport jsonimport repostUrl = 'https://***.kairisei-ma.jp/Game/CardCollectionShow'proxies=&#123; 'http':'127.0.0.1:1080', 'https':'127.0.0.1:1080'&#125;headers = &#123; 'content-type': 'application/x-www-form-urlencoded', 'User-Agent': 'man/7.0.2 CFNetwork/897.15 Darwin/17.5.0'&#125;post_data = '1CbgciYwEfnY8w1qs2I61TapxEmEE=' #每隔一分钟会更新,抓包获取r = requests.post(postUrl,data=post_data,proxies=proxies,headers=headers)print(r)urlArr = re.findall(r'cardid":(\d+)',r.text)Base = 'http://****.kairisei-ma.jp/i198498/chr51/chr51_'def proxyDownloadImg(url): file_name = url.split('/')[-1] img = requests.get(url,proxies=proxies) with open(file_name, 'wb') as file: file.write(img.content) print(file_name,'下载成功')def main(urlArr): for num in urlArr: url = Base + str(num) + '.png' proxyDownloadImg(url)main(urlArr) 待完善的地方 当然还是多线程更快吧 记录下载成功的图片,下次有卡牌更新就可以跳过已下载的图片 结语通过这次突发奇想，既复习了下python,也得到了自己想要的卡牌数据，还是很值得的。]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html2canvas使用小结]]></title>
    <url>%2F2018%2F07%2F22%2Fhtml2canvas%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[html2canvas顾名思义,就是将html转化为canvas。日常开发中可以将一个活动页生成canvas然后转换成图片分享传播。最近两个项目都用到了html2canvas,也遇到了一些常见的问题。所以小结下经验。 贴上 html2canvas 的github地址 生成内容不完整的情况1. 元素超过容器设置的高度12345&lt;!-- 生成canvas的容器 --&gt;&lt;div id="to-canvas" class="wrap"&gt; &lt;img src="./bg.jpg" width="300px" height="300px" alt=""&gt; &lt;div class="content"&gt;测试内容&lt;/div&gt;&lt;/div&gt; 123456/* css */.wrap&#123; width:300px; height:300px; margin:0 auto;&#125; 容器高度为300,图片的高度为300,那么文字就超过容器的高度了，所以生成的canvas是不会显示文字的。 2. 容器设置了translate12345678&lt;!-- html不变 只修改wrap的css--&gt;.wrap&#123; position: absolute; top:50%; left: 50%; transform: translate(-50%,-50%); width:300px;&#125; 这样生成的canvas是一个整体向上、向左移动50%（?）只显示了容器的右下部分 一些小技巧？1.要转换成canvas容器不显示在页面设置容器的opacity:0; 设置成visibility: hidden;以及display:none会生成空白的canvas 2.生成图片跨域问题。图片base64位,或者添加一个配置123html2canvas(document.querySelector('#to-canvas'),&#123; useCORS: true&#125;) 3.图片高清问题用的最新版的,发现生成的canvas是根据设备dpr变化的。保证了canvas的高清。网上很多是通过创建一个自定义canvas。添加一个scale配置。 4.transform.js 和 html2canvas如果容器内部的img元素使用了transform.js,这个元素需要设置定位top,left值，否则容器上设置的border-radius,会影响到该元素，使其也带有圆角属性。]]></content>
      <categories>
        <category>js插件</category>
      </categories>
      <tags>
        <tag>html2canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端复习笔记-1]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[em….平时喜欢浏览掘金,github搜集记录了一些面试或者日常开发常见的知识点,文中会注明出处,可能会有疏忽露掉的地方。还望见谅。。。 基本类型,引用类型,ES6新增类型 基本类型：undefined,null,string,boolean,number引用类型：objectES6 新增基本类型：symbolES6 新增数据结构：Set,Map 基本类型和引用类型的区别： https://www.jianshu.com/p/6f3de7e9fc51 call,apply,bind,new,Object.createcall,apply的实现call 函数特点： 改变this指向 给定参数执行函数 this 参数可以传 null，当为 null 的时候，视为指向 window 函数是可以有返回值的 模拟的步骤可以分为: 将函数设为对象的属性 执行该函数 删除该函数 简单版：12345Function.prototype._call = function(context) &#123; context.fn = this; context.fn(); delete context.fn;&#125; 完整版：1234567891011Function.prototype._call = function(context) &#123; context = context || window context.fn = this; var args = []; for(var i = 1;i &lt; arguments.length;i++)&#123; args.push('arguments[' + i + ']'); &#125; var res = eval('context.fn(' + args + ')') delete context.fn; return res;&#125; ES6版：1234567Function.prototype._call = function(context, ...args) &#123; context = context || window; context.__fn__ = this; let res = context.__fn__(...args); delete context.__fn__; return res;&#125; apply的实现完整版：1234567891011121314151617Function.prototype._apply = function(context, arr) &#123; context = context || window; context.fn = this; var res; if (!arr) &#123; res = context.fn(); &#125; else &#123; var agrs=[]; for(var i = 0;i &lt; arr.length;i++)&#123; args.push('arr[' + i + ']') &#125; res = eval('context.fn(' + args + ')') &#125; delete context.fn; return res;&#125; ES6版：1234567Function.prototype._apply = function(context, arr) &#123; context = context || window; context.fn = this; let res = !arr ? context.fn() : context.fn(...arr); delete context.fn; return res;&#125; bind 的实现bind的特点： 返回一个函数 可以传入参数 函数有返回值 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效 简洁版：123456Function.prototype._bind = function(context) &#123; var self = this; return function() &#123; return self.apply(context) &#125;&#125; 未实现构造函数版：12345678910Function.prototype._bind = function(context) &#123; var self = this; //获取第二个参数到最后一个参数 var args = [].slice.call(arguments, 1); return function() &#123; // 获取bind返回函数传入的参数 var bindArgs = [].slice.call(arguments); return self.apply(context, args.concat(bindArgs)) &#125;&#125; bind返回函数做为构造函数时：123456789101112131415161718192021222324var value = 2;var foo = &#123; value: 1&#125;;function bar(name, age) &#123; this.habit = 'shopping'; console.log(this.value,'this.value'); console.log(name,'name'); console.log(age,'age');&#125;bar.prototype.friend = 'kevin';var bindFoo = bar.bind(foo, 'daisy');var obj = new bindFoo('18');// undefined// daisy// 18console.log(obj.habit);console.log(obj.friend);// shopping// kevin 尽管在全局和 foo 中都声明了 value 值,bind 返回的函数 bindFoo 作为 构造函数时，this.value 为undifined,说明绑定的 this 失效了,但是obj 依然继承了bar.prototype上的属性。 详细参考https://github.com/mqyqingfeng/Blog/issues/12 完整版：12345678910111213141516171819202122232425Function.prototype._bind = function(context) &#123; //调用 bind 的不是函数 报错 if (typeof this !== "function") &#123; throw new Error("Function.prototype._bind - what is trying to be bound is not callable"); &#125; var self = this; var args = [].slice.call(arguments,1); var fBound = function() &#123; var bindArgs = [].slice.call(arguments); // 当作为构造函数时 this 指向实例 fBound ,将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值, // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window return self.apply(this instanceof fBound ? this : context,args.concat(bindArgs)); &#125; // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 var fNOP = function() &#123;&#125;; fNOP.prototype = self.prototype; fBound.prototype = new fNOP(); // 另一个写法 //fBound.prototype = Object.create(self.prototype); return fBound;&#125; Object.createObject.create() 的实现:12345Object.create = function(o) &#123; function f() &#123;&#125; f.prototype = o; return new f;&#125;; new 的模拟实现12345678function objectFactory() &#123; var args = Array.prototype.slice.call(arguments); var Constructor = args.shift(); var instance = Object.create(Constructor.prototype); var temp = Constructor.apply(instance, args); return (typeof temp === 'object' &amp;&amp; temp !== null) ? temp : instance;&#125; 类型判断 typeof 能检测出基本类型(包括symbol)和Object Object.prototype.toString.call() 更加具体 isType123var isType = function (obj) &#123; return Object.prototype.toString.call(obj).slice(8,-1);&#125; EmptyObjectjQuery提供了 isEmptyObject 方法来判断是否是空对象：1234567function isEmptyObject(obj)&#123; //typeof obj ==="object" 是否需要？ for(var name in obj)&#123; return false &#125; return true;&#125; Window对象Window 对象作为客户端 JavaScript 的全局对象，它有一个 window 属性指向自身123function isWindow(obj) &#123; return obj != null &amp;&amp; obj === obj.window&#125; isElement判断对象是不是DOM元素123isElement = function(obj) &#123; return !!(obj &amp;&amp; obj.nodeType === 1);&#125; 数组去重,排序,深浅拷贝,乱序,最大/最小值,扁平化,查找指定元素,判断对象相等数组去重indexOf 对象和 NaN 不去重indexOf 底层还是使用 === 进行判断，因为 NaN === NaN的结果为 false，所以使用 indexOf 查找不到 NaN 元素 1234567891011var arr = [1, 2, 1, '1']function unique(arr) &#123; var res = []; for(var i = 0;i &lt; arr.length;i++)&#123; var current = arr[i]; if(res.indexOf(current) === -1)&#123; res.push(current) &#125; &#125; return res;&#125; 增加拓展函数1234567891011function unique(arr, fn) &#123; var res = []; for(var i = 0;i &lt; arr.length;i++)&#123; var current = arr[i], computed = fn ? fn(current, i, arr) : current; if(res.indexOf(computed) === -1)&#123; res.push(computed) &#125; &#125; return res;&#125; filter 对象不去重, NaN 会被忽略掉 12345function unique(arr) &#123; return arr.filter(function(item, index, array) &#123; return array.indexOf(item) == index; &#125;)&#125; Object键值对 全部都能去重 1234567function unique(arr) &#123; var obj = &#123;&#125;; return arr.filter(function(item, index, array) &#123; var itemKey = typeof item + JSON.stringify(item); return obj.hasOwnProperty(itemKey) ? false : (obj[itemKey] = true) &#125;)&#125; Set和Map(ES6) 对象不去重 NaN 去重 1234567// Setlet unique = (arr) =&gt; [...new Set(arr)]// Maplet unique = (arr) =&gt; &#123; const seen = new Map(); return arr.filter((item) =&gt; !seen.has(item) &amp;&amp; seen.set(item, true))&#125; 深浅拷贝 参考https://juejin.im/post/5acc7e606fb9a028c67609f7 排序 参考 https://www.jianshu.com/p/8d30da8b832e 快速排序是处理大数据最快的排序算法之一：12345678910function quickSort(arr) &#123; if (arr.length == 0) return []; var left = [], right = [], pivot = arr[0]; for (var i = 1; i &lt; arr.length; i++) &#123; arr[i] &lt; pivot ? left.push(arr[i]) : right.push(arr[i]) &#125; return quickSort(left).concat(pivot, quickSort(right));&#125; 乱序Math.random 乱序的不彻底 1234var arr = [1, 2, 3, 4, 5]arr.sort(function() &#123; return Math.random() - 0.5&#125;) Math.random() - 0.5 随机得到一个正数、负数或是 0，如果是正数则降序排列，如果是负数则升序排列，如果是 0 就不变，然后不断的升序或者降序，最终得到一个乱序的数组。 Fisher–Yates 当前元素与数组中的一个随机元素交换 12345678function shuffle(arr) &#123; var l = arr.length, r; while(l)&#123; r= Math.floor(Math.random() * l--); [arr[l], arr[r]] = [arr[r], arr[l]]; &#125; return arr;&#125; sort(random order) 用于整数 123456function shuffle(arr) &#123; var _random = arr.map(Math.random); return arr.sort(function(a, b)&#123; return _random[a] - _random[b] &#125;)&#125; 参考：https://bost.ocks.org/mike/shuffle/compare.html 最大/最小值Math.max()返回一组数中的最大值，需要注意的是： 如果有任一参数不能转化为数值，则结果为NaN。 如果没有参数，结果为-Infinity(负无穷大) for循环12345678function ArrMax(arr) &#123; // 未对数组内的值进行判断 for(var i = 1;i &lt; arr.length;i++)&#123; var res = arr[0]; res = Math.max(res, arr[i]) &#125; return res&#125; ruduce12345function ArrMax(arr) &#123; return arr.reduce(function(prev, next) &#123; return Math.max(prev, next) &#125;)&#125; evel12var arr = [3, 4, 7, 21, 5]var max = eval("Math.max(" + arr + ")") apply12var arr = [3, 4, 7, 21, 5]var max = Math.max.apply(null, arr) ES612var arr = [3, 4, 7, 21, 5]var max = Math.max(...arr) 扁平化数组的扁平化，就是将一个嵌套多层的数组转换为只有一层的数组 toString如果数组的元素都是数字/字符串，那么我们可以考虑使用 toString 方法123456// numbelarr.toString().split(',').map(function(item) &#123; return +item;&#125;);// stringarr.toString().split(','); 递归循环123456789101112function flatten(arr) &#123; var res = []; for(var i = 0;i &lt; arr.length;i++)&#123; var item = arr[i]; if (Array.isArray(item)) &#123; res = res.concat(flatten(item)) &#125; else &#123; res.push(item) &#125; &#125; return res;&#125; reduce12345function flatten(arr) &#123; return arr.reduce(function(prev, next) &#123; return prev.concat(Array.isArray(next) ? flatten(next) : next); &#125;, [])&#125; ES6123456let flatten = (arr) =&gt; &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr) &#125; return arr;&#125; 查找数组中指定元素findIndex()(es6)方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。12345var arr = [1, 23, 34, 53]arr.findIndex(function(item, index, array) &#123; return item &gt; 30&#125;)//2 实现findIndex遍历一遍，返回符合要求的值的下标12345678910function findIndex(arr, fn, context) &#123; for(var i = 0;i &lt; arr.length;i++)&#123; if(fn.call(context, arr[i], i, arr)) return i &#125; return -1;&#125;var arr = [1, 23, 34, 53]findIndex(arr, function(item, index) &#123; if(item &gt; 30) return true;&#125;) sortedIndex在一个排好序的数组中找到 value 对应的位置，保证插入数组后，依然保持有序的状态,效果为：sortedIndex([10, 20, 30], 25); // 2 对于有序的数组，那我们就不需要遍历，大可以使用二分查找法，确定值的位置 123456789101112function sortedIndex(arr, tag) &#123; var low = 0,high = arr.length; while (low &lt; high) &#123; var mid = Math.floor((low + high) / 2); if(arr[mid] &lt; tag) low = mid + 1; else high = mid; &#125; // 返回插入的位置 return high; //直接插入，返回最后的结果 //return arr.splice(high,0,tag) &amp;&amp; arr;&#125; 拓展下上面的函数，使其支持包含对象的数组。支持按照对象中的键值查找123456789101112131415161718//拓展 (未做对象判断,异常处理)function sortedIndex(arr, tag, key) &#123; var low = 0, high = arr.length; while(low &lt; high)&#123; var mid = Math.floor((low + high) / 2), arr_mid, _tag; arr_mid = key ? arr[mid][key] : arr[mid]; _tag = key ? tag[key] : tag; if (arr_mid &lt; _tag) low = mid + 1; else high = mid; &#125; // 返回插入的位置 return high; //直接插入，返回最后的结果 //return arr.splice(high, 0, tag) &amp;&amp; arr;&#125;var test = [&#123;name: 'test1', age: 10&#125;, &#123;name: 'test2', age: 30&#125;];sortedIndex(test, &#123;name: 'test3', age: 20&#125;, 'name'); //2sortedIndex([10, 20, 30, 40, 50], 35)//3 本节参考：https://github.com/mqyqingfeng/Blog/issues/37 判断对象相等简单版：JSON.stringify(obj) 函数闭包,柯里化,尾调用,递归闭包 参考：https://juejin.im/post/58cf180b0ce4630057d6727c 文中拓展：promise及async await 尾调用,递归 参考 https://juejin.im/post/5acdd7486fb9a028ca53547c 函数柯里化ES6的写法比较好懂，而且简短1234567var curry = (fn, ...args) =&gt; fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args)var test = curry(function(a, b, c) &#123; console.log([a, b, c])&#125;) 防抖,节流,懒加载,预加载防抖12345678910111213function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; clearTimeout(timeout) timeout = setTimeout(function() &#123; func.apply(context, args) &#125;, wait); &#125;&#125; 节流12345678910111213141516function throttle(func, wait) &#123; var timeout; var previous = 0; return function() &#123; context = this; args = arguments; if (!timeout) &#123; timeout = setTimeout(function() &#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 防抖和节流的区分：防抖是虽然事件持续触发，但只有等事件停止触发后 n 秒才执行函数，节流是持续触发的时候，每 n 秒执行一次函数 详细参考：https://github.com/mqyqingfeng/Blog/issues/26 事件委托 参考：https://juejin.im/post/58f558efac502e006c3e5c97 文中拓展：requestAnimationFrame 、 DocumentFragment Promise http://es6.ruanyifeng.com/#docs/promisehttp://www.cnblogs.com/lunlunshiwo/p/8852984.html Promise的内部，有一个状态管理器的存在，有三种状态：pending、fulfilled、rejected。 promise 对象初始化状态为 pending。 当调用resolve(成功)，会由pending =&gt; fulfilled。 当调用reject(失败)，会由pending =&gt; rejected。 注意promsie状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变 ES7 async/await12345678910111213let res = await func()//等价于func().then(res =&gt;&#123; //&#125;)async function func() &#123; return 1;&#125;// 等价于function func() &#123; return new Promise(resolve =&gt; resolve(1))&#125; 结合使用fetch,async/await获取用户数据：12345678910async function getUserByAsync(url,method = 'json',option) &#123; var result = await fetch(url,option); // fetch 请求错误并不会报错，所以要根据status判断是否请求成功 if(result.status) return result[method](); else throw new Error('error')&#125;getUserByAsync('https://api.github.com/users/你的账户') .then(res =&gt; getUserByAsync('https://api.github.com/users/另一个请求', 'text')) .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err)) fetch除了XMLHttpRequest对象来获取后台的数据之外，还可以使用一种更优的解决方案fetch。 参考：https://segmentfault.com/a/1190000011433064 tcp/http 参考：https://juejin.im/post/5ad4094e6fb9a028d7011069 Cookie、session和Web Storage 参考地址：https://juejin.im/post/5ad5b9116fb9a028e014fb19 vue MVVM原理以及实现参考： https://juejin.im/post/5abdd6f6f265da23793c4458 https://github.com/DMQ/mvvm/blob/master/readme.md 看不懂系列 深度剖析：如何实现一个 Virtual DOM 算法https://github.com/livoras/blog/issues/13]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义可迭代对象]]></title>
    <url>%2F2018%2F01%2F08%2Fpython%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Python3学习笔记-自定义可迭代对象 Question1实现一个连续浮点数发生器FloatRange(和range类似),根据给定范围(start,end)和步进值(step)产生一系列连续浮点数,例如: FloatRange(3.0,4.0,0.2) 可产生:正向: 3.0 -&gt; 3.2 -&gt; 3.4 … -&gt;4.0反向: 4.0 -&gt; 3.8 -&gt; 3.6 … -&gt;3.0 正向(使用迭代器 __iter__) 反向(使用迭代器 __reversed__) 12345678910111213141516171819class FloatRange(): def __init__(self, start, end, step=0.1): self.start = start self.end = end self.step = step # 正向迭代器 def __iter__(self): t = self.start while t &lt;= self.end: yield t t += self.step # 反向迭代器 def __reversed__(self): t = self.end while t &gt;= self.start: yield t t -= self.step 正向实例 调用 __iter__12for x in FloatRange(1.0, 4.0, 0.5): pass 反向实例 reversed() 调用__reversed__12for x in reversed(FloatRange(1.0, 4.0, 0.5)): pass Question2实现一个可迭代对象的类，它能迭代出给定范围内的所有质数1234567891011121314151617181920212223242526272829class PrimeNumbers: def __init__(self,start,end): # 存储开始和结束的值 self.start = start self.end = end # 判断函数 def isPrimeNum(self,k): if k&lt;2: return False for i in range(2,k): if k % i == 0: # 说明是合数 return False # 说明没有 i 能被 k 整除 return True # 迭代器接口 def __iter__(self): for k in range(self.start,self.end + 1): if self.isPrimeNum(k): yield kfor x in PrimeNumbers(1,100): print(x)]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列元素排序统计]]></title>
    <url>%2F2018%2F01%2F05%2Fpython%E2%80%94%E5%BA%8F%E5%88%97%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Python3学习笔记-序列元素排序统计 question：找出一个列表中重复次数最多的三个元素 先生成一个30位长度，元素在0~20之间的列表123from random import randintdata = [randint(0,20) for i in range(30)] 创建一个新的dict12345...# 统计结果用dict 显示 &#123;值:次数&#125;# 初始化字典 dict.fromkeys(键,初始值) c = dict.fromkeys(data,0)... 方法一统计相同元素出现的次数12for x in data: c[x] += 1 再对统计结果进行排序1sorted(c.items(),key=lambda item:item[1],reverse=True) 方法二12345from collections import Counterc2 = Counter(data)# 统计出现频率 最高的 3 个元素c2.most_common(3)]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现头尾固定，内容滚动]]></title>
    <url>%2F2018%2F01%2F05%2Fflex%E2%80%94%E5%A4%B4%E5%B0%BE%E5%9B%BA%E5%AE%9A%EF%BC%8C%E5%86%85%E5%AE%B9%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[实现一个头尾固定，中间内容滚动的布局，一种方案就是头尾用position:flex,另一种利用flex布局。相比较第一种，第二种更简洁，而且在移动端表现要更好些…… HTML部分1234567&lt;section class="wrap"&gt; &lt;header&gt;header&lt;/header&gt; &lt;section class="content"&gt; &lt;p&gt;内容&lt;/p&gt; &lt;/section&gt; &lt;footer&gt;footer&lt;/footer&gt;&lt;/section&gt; css 部分12345*&#123;margin:0;padding:0&#125;section,header,footer&#123;display:block&#125;html,body&#123;width:100%;height:100%&#125;.wrap&#123;display: flex;flex-direction:column;height:100%&#125;.content&#123;flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拆分字符串]]></title>
    <url>%2F2018%2F01%2F04%2Fpython%E2%80%94%E6%8B%86%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Python3学习笔记-拆分字符串 把 某个 字符串依据分隔符 拆分不同的字段,该字符串含多种不同的分隔符，例如:s = &#39;ab;cd|efg|hi,jklmn\topq;rst,uvw\txyz&#39;,;|\t 都是分隔符 方法一 使用str.split 依次过滤12345678910111213def my_split(s, ds): res = [s] for d in ds: t = [] # 将依次结果追加到 t 中 list(map(lambda x: t.extend(x.split(d)), res)) res = t # 再过滤空字符串,只有当 x 存在才返回值 return [x for x in res if x]my_split(s, ',;|\t') 方法二 使用re.split 一次性拆分字符串1234# re.split(pattern, string, maxsplit=0, flags=0)import reres = re.split('[,;|\t]+',s)]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对迭代器进行切片]]></title>
    <url>%2F2018%2F01%2F03%2Fpython%E2%80%94%E5%AF%B9%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[Python3学习笔记-对迭代器进行切片 question:读取一个文本文件一定范围之间的内容(如100~300行) 方法一使用readlines()[100:300]将文件的每一行读入到列表中，再对列表切片缺点：会一次性将文件读入到内存中，如果文件过大，会影响效率。 1f = open('file',encoding='utf-8').readlines()[100:300] 方法二使用islice(iterable, start, stop[, step]) --&gt; islice object12345678from itertools import islicelines1 = islice(f,100,300) # 100 ~ 300lines2 = islice(f,100,None) # 100 ~ 最后for line in lines1: pass islice 会 消耗 原迭代对象, 原迭代对象 会从 islice 切片后末尾开始迭代]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速找到多个字典中的公共键]]></title>
    <url>%2F2018%2F01%2F02%2Fpython%E2%80%94%E5%A4%9A%E4%B8%AA%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E5%85%AC%E5%85%B1%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Python3学习笔记-快速找到多个字典中的公共键 方法一：for循环 判断key 是否同时在其他两个dict,这种方法通俗易懂 方法二：利用map/reduce,相比第一种方法更加简洁。有Python味道 随机产生 3 组 dict1234567891011from random import randint, sample# 假定样本 为 YY = 'abcdefg'# 对样本随机取样 3~6 个 =&gt; sample(Y, randint(3, 6))# 生成 3组 值在 1~4的 dictt1 = &#123;x: randint(1, 4) for x in sample(Y, randint(3, 6))&#125;t2 = &#123;x: randint(1, 4) for x in sample(Y, randint(3, 6))&#125;t3 = &#123;x: randint(1, 4) for x in sample(Y, randint(3, 6))&#125; 找出这三组 dict 的公共键为了方便运行时查看结果,我自作聪明定义一个装饰器1234567def print_res(func): def wrapper(): print(t1) print(t2) print(t3) print(func()) return wrapper 方法一 for循环 判断key 是否同时在其他两个dict1234567891011# 方法一@print_resdef method_1(): res = [] for i in t1: # 判断是否同时在 t2 t3 if i in t2 and i in t3: res.append(i) return resmethod_1() 方法二 利用map/reduce123456789from functools import reduce@print_resdef method_2(): m = map(dict.keys, [t1, t2, t3]) res = reduce(lambda a, b: a &amp; b, m) return resmethod_2()]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代多个对象]]></title>
    <url>%2F2017%2F12%2F29%2Fpython%E2%80%94%E8%BF%AD%E4%BB%A3%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Python3学习笔记-迭代多个对象 情景一(并行)：某班学生期末考试成绩语文，数学，英语分别存储在3个列表中，同时迭代 3 个列表。计算每个学生的总分 情景二(串行)：某年级有 4 个班，某次考试每班英语成绩分别存储在4 个列表中，依次迭代每个列表，统计全年级成绩高于 90 分的人数 情景一(并行)12345678910111213from random import randint# 随机生成 40个学生的 语文 数学 英语成绩，取值范围在 60~100chinese = [randint(60, 100) for x in range(40)]math = [randint(60, 100) for x in range(40)]english = [randint(60, 100) for x in range(40)]total = []# 利用zip 合并 三科成绩，然后拆包for c, m, e in zip(chinese, math, english): total.append(c + m + e) 情景二(串行)12345678910111213141516from itertools import chain# 随机生成 4 个 班级e1 = [randint(30, 100) for i in range(40)]e2 = [randint(40, 100) for i in range(50)]e3 = [randint(50, 100) for i in range(45)]e4 = [randint(30, 100) for i in range(43)]# 定义初始值count = 0for s in chain(e1, e2, e3, e4): if s &gt; 90: count += 1print(count)]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有序字典]]></title>
    <url>%2F2017%2F12%2F28%2Fpython%E2%80%94%E6%9C%89%E5%BA%8F%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[Python3学习笔记-有序字典 question：假定有一个抢答环节，有ABCDEF几个成员。将他们的答题答案和时间记录下来，答题完毕后按照时间先后顺序打印出来123456789101112131415161718192021222324252627from collections import OrderedDictfrom random import randintfrom time import time# 定义一个有序字典d = OrderedDict()players = list('ABCDEF')# 开始时间start = time()for i in range(0, len(players)): input() # 随机选取一名，记录下来，并从列表移除 p = players.pop(randint(0, len(players) - 1)) # 结束时间 end = time() print(i + 1, p, end - start) # 按照顺序存储在 有序字典 中 d[p] = (i + 1, end - start)print('------------------结果----------------------')for i in d: print(i, d[i])]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3枚举]]></title>
    <url>%2F2017%2F12%2F27%2Fpython%E2%80%94%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[Python3学习笔记-枚举 访问元组中的数据时会使用index访问，大量的索引会降低程序的可读性，这时我们可以使用枚举来提高程序的可读性 定义一个枚举类型12345678# 导入 Enum 模块form enum import Enum# Student类 继承 Enumclass Student(Enum): name = 0 age = 1 sex = 2 定义枚举时，成员名称 不允许重复(装饰器@unique 可以检测重复) 两个相同值的成员，第二个成员的名称被视作第一个成员的别名 如果枚举中存在相同值的成员，在通过值获取枚举成员时，只能获取到第一个成员 枚举取值1234567print(Student.age) # =&gt; Student.ageprint(Student.age.name) # =&gt; ageprint(Student.age.value) # =&gt; 1print(Student(1)) # =&gt; Student.ageprint(Student(1).name) # =&gt; ageprint(Student(1).value) # =&gt; 1 枚举可以迭代123456for item in Student: print(item)Student.nameStudent.ageStudent.sex 枚举应用 student = (&#39;admin&#39;, 18, &#39;男&#39;) 获取 student 的 age : 索引访问：student[1] –&gt; 18 枚举： student[Student.age.value] –&gt; 18]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析与过滤]]></title>
    <url>%2F2017%2F12%2F26%2Fpython%E2%80%94%E8%A7%A3%E6%9E%90%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[Python3学习笔记-解析与过滤 列表解析12345678910from random import randint# 生成 -10~10 的10 个 随机数data = [randint(-10,10) for i in range(10)]# 过滤负数### 1.ilter(function or None, iterable)--&gt; filter objecta = list( filter(lambda x:x&gt;= 0,data) )### 2.列表解析b = [x for x in data if x&gt;=0] 字典解析123456789# 随机生成一个 人名: 分数 的字典 d = &#123;x:randint(60,100) for x in range(1,20)&#125;## 过滤出分数大于90的D = &#123;key:value for key,value in d.items() if value&gt;90 &#125;print(D) 集合解析1234567s = set(data)## 过滤能被 3 整除的S = &#123;x for x in s if x % 3 == 0&#125;print(S) 字典代替 switch123456789101112day = 0def test(): print('this is test') switcher = &#123; 0 : 'Sunday', 1 : 'Monday', 2 : 'Tuesday', 3 : test&#125;switcher.get(day,'none')]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
</search>
