---
title: 前端复习笔记-2
comments: false
is_update: false
date: 2018-09-02 22:05:36
tags: [笔记]
categories: 笔记
songid:
photos:
---
{% note info %}一边看大佬们的博客一边总结(缓更){% endnote %}

### 词法作用域
> 文章链接 https://github.com/mqyqingfeng/Blog/issues/3  

大佬的博客们,除了文章写的深刻,丰富,其次评论也是很精彩的。通过评论可以加深理解以及拓展更多知识。
这篇文章的重点：
> JavaScript是采用词法作用域的，这就意味着函数的执行依赖于函数定义的时候所产生（而不是函数调用的时候产生的）的变量作用域  

理解这个后下面这些例子也就很快想明白了：
```js
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();
// 结果 为 1 
// 先执行 bar() , 在执行 foo() , foo() 函数定义在最外层, 所以会输出最外层的 value 值
```
<!-- more -->
《JavaScript权威指南》中的例子:
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
// 先执行 checkscope() , 返回 f, 然后执行 f(), f() 定义在 checkscope()内部且其内部有scope 变量, 所以结果 为 local scope
```
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
// 执行 checkscope(), 然后执行 f() , f() 定义在 checkscope()内部且其内部有scope 变量, 所以结果 为 local scope
```
评论中的例子：
```js
var value = 1;
var f = function() { console.log(value) }
function out(f) {
  var value = 2;
  f();
}
out(f)
// 执行 out(f), 然后执行f(), f() 定义的位置在最外层，所以输出结果为 最外层的 1
```
### 变量提升/函数提升
> 原文：  
> https://github.com/mqyqingfeng/Blog/issues/4  
> https://github.com/mqyqingfeng/Blog/issues/5  

文章讲了函数执行上下文栈，变量对象。 除了看文章，评论也十分精彩。
下面是原文的两段代码：
```js
var foo = function () {
  console.log('foo1');
}
foo();  // foo1

var foo = function () {
  console.log('foo2');
}

foo(); // foo2
```
```js
function foo() {
  console.log('foo1');
}

foo();  // foo2

function foo() {
  console.log('foo2');
}

foo(); // foo2
```
这两段代码涉及到函数提升以及变量提升，将他们改成函数提升/变量提升后的结果为：
```js
// 第一段
var foo;
foo = function() {
  console.log('foo1')
}

foo() // foo1

foo = function() {
  console.log('foo2')
}

foo() //foo2
```
```js
// 第二段
function foo() {
  console.log('foo1')
}
function foo() {
  console.log('foo2')
}
foo() // foo2
foo() // foo2
```
第一段代码是变量提升，第二段代码是函数提升
评论中的例子：
```js
// 函数声明可以提升
foo(); // foo
function foo() {
  console.log('foo');
}
```
```js
// 函数表达式不会提升 ，提升的是 变量 foo
foo(); // TypeError: undefined is not a function
var foo = function() {
  console.log('foo');
}
// 提升后的代码
var foo;
foo() // TypeError: undefined is not a function
foo = function() {
  console.log('foo')
}
```
关于函数提升和变量提升优先级问题：
```js
console.log(foo);

function foo(){
  console.log("foo");
}
var foo = 1;
// 打印 函数 而不是 undefined

// 变量提升之后
function foo() {console.log('foo')}; // 函数提升
var foo; // 变量名称和函数名重复了，被忽略
console.log(foo) // 打印全局的 foo = 1
foo = 1 // foo 赋值为 1
console.log(foo()) // 报错  foo() 已被赋值为 1  
```
下面是评论中的带形参的例子：
```js
function fun(a){
   var a;
   console.log(a);
   a = 2;
}

fun(1);  // 打印 1
```
`fun`存在变量 `a` , 为什么结果不是 `undefined`,而是形参呢？
在看下第二种情况 , `fun` 内部有同名函数时：
```js
function fun(a){
   var a;
   console.log(a);
   function a(){
     console.log('a')
   }
   a = 2;
}
fun(1);  // 打印 a()
```
结果打印的是函数，说明函数提升了,而且替换了形参。变换后的代码如下：
```js
function fun(a) {
  function a(){console.log('a')}; // 函数提升
  var a; // 变量名称和函数名重复了，被忽略
  console.log(a)
  a = 2
}
fun(1) // 打印 a()
```
看了两种情况，最大的问题时形参和变量提升，函数提升有什么关系？
判断的方式为：
1. 分析形参，值为1
2. 分析函数，不存在，则不替换
3. 分析变量，已经存在，不修改

**最后针对变量提升总结为** 
-  变量申明和函数申明(整体)会被提升，函数表达式提升的是申明变量，函数本身不提升; 
- 首先会处理函数声明，其次会处理变量声明，如果 **变量名称**  跟 **已经声明** 的 **形式参数或函数相同**，则变量声明不会干扰已经存在的这类属性

另外评论中还有一道关于引用指向问题：
```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };
console.log(a); // {n:2}
console.log(b); // {n:1, x: {n:2}}
```
- 前两步 `a , b` 都指向 同一个对象 `{n: 1}`
- `a.x = a = {n: 2}` 点运算符优先级最高 `a.x` 相当于 `{n:1}.x` , 连等从右往左, `a = {n: 2}` , `{n: 1}.x = {n: 2}` 。`a` 的指向变成了新对象 `{n: 2}`, 对象 `{n: 1}` 增加了 `x` 属性。 `b` 一直指向对象`{n: 1}`  

### ** this ** 指向
> 原文 https://github.com/mqyqingfeng/Blog/issues/7  

博客大佬是从规范来解答 `this` 指向的。其实我更喜欢评论中的总结（捂脸）:
`this` 一般的几种调用场景：
`var obj = {a: 1, b: function(){console.log(this);}}`
1. 作为对象调用时，指向该对象 `obj.b()`; // 指向 `obj`
2. 作为函数调用, `var b = obj.b; b()` ; // 指向全局 `window`
3. 作为构造函数调用 `var b = new Fun()` ; // `this` 指向当前实例对象
4. 作为 `call` 与 `apply` 调用 `obj.b.apply(object, [])` ; // `this` 指向当前的 `object`

感觉 `this判断` 和 `词法作用域` 判断会有点混淆（捂脸）

### 数组
> 文章来源：https://juejin.im/post/5aa7d82c6fb9a028c522de43  

在一个数组中 找出里面其中两项相加后的和为num，如果存在就返回两个数的索引位置，否则false(原)
```js
// 原
function fn(num = 0, ary = []) {
  for (let i = 0; i < ary.length; i++) {
    let diff = num - ary[i];
    let diffIndex = ary.indexOf(diff);
    if (diffIndex !== -1) {
      return [i, diffIndex];
    }
  }
  return false;
}

let num = 3;
let arr = [-1, 4, 6, 2];

console.log(fn(num, arr)); // [0, 1]
```
自己对需求做了一点改变：找出数组 `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`,找出相加为 `10`, 如果存在就返回两个数的索引位置的集合，否则false, 每个数字只参与一次组合，并且自身不与自身相加（改）
```js
// 在原本的基础上做了一点小修改
// 待优化： 增加参数控制。满足不同需求结果
function findAddNum(arr, num){
  var res = []
  var array = [].concat(arr) // 不改变原数组
  for(var i = 0; i < array.length; i++) {
    var diff = num - array[i]
    var diffIndex  = array.indexOf(diff)
    // 自身不参与重复相加 : 不出现 [5,5]
    if(diffIndex !== -1 && diffIndex !== i) {
      array[diffIndex] = null // 每个数字只参与一次 不会出现[0,10][10,0]
      res.push([i, diffIndex])
    }
  }
  return res.length > 0 ? res : false
}
findAddNum([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10)
// [0, 10],[1, 9],[2, 8],[3, 7], [4, 6]
```
