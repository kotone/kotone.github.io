---
title: 前端复习笔记-2
comments: false
is_update: false
date: 2018-09-02 22:05:36
tags: [笔记]
categories: 笔记
songid:
photos:
---
{% note info %}一边看大佬们的博客一边总结(缓更){% endnote %}

### 词法作用域
> 文章链接 https://github.com/mqyqingfeng/Blog/issues/3  

大佬的博客们,除了文章写的深刻,丰富,其次评论也是很精彩的。通过评论可以加深理解以及拓展更多知识。
这篇文章的重点：
> JavaScript是采用词法作用域的，这就意味着函数的执行依赖于函数定义的时候所产生（而不是函数调用的时候产生的）的变量作用域  

理解这个后下面这些例子也就很快想明白了：
```js
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();
// 结果 为 1 
// 先执行 bar() , 在执行 foo() , foo() 函数定义在最外层, 所以会输出最外层的 value 值
```
<!-- more -->
《JavaScript权威指南》中的例子:
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
// 先执行 checkscope() , 返回 f, 然后执行 f(), f() 定义在 checkscope()内部且其内部有scope 变量, 所以结果 为 local scope
```
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
// 执行 checkscope(), 然后执行 f() , f() 定义在 checkscope()内部且其内部有scope 变量, 所以结果 为 local scope
```
评论中的例子：
```js
var value = 1;
var f = function() { console.log(value) }
function out(f) {
  var value = 2;
  f();
}
out(f)
// 执行 out(f), 然后执行f(), f() 定义的位置在最外层，所以输出结果为 最外层的 1
```
### 数组
> 文章来源：https://juejin.im/post/5aa7d82c6fb9a028c522de43  

在一个数组中 找出里面其中两项相加后的和为num，如果存在就返回两个数的索引位置，否则false(原)
```js
// 原
function fn(num = 0, ary = []) {
  for (let i = 0; i < ary.length; i++) {
    let diff = num - ary[i];
    let diffIndex = ary.indexOf(diff);
    if (diffIndex !== -1) {
      return [i, diffIndex];
    }
  }
  return false;
}

let num = 3;
let arr = [-1, 4, 6, 2];

console.log(fn(num, arr)); // [0, 1]
```
自己对需求做了一点改变：找出数组 `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`,找出相加为 `10`, 如果存在就返回两个数的索引位置的集合，否则false, 每个数字只参与一次组合，并且自身不与自身相加（改）
```js
// 在原本的基础上做了一点小修改
// 待优化： 增加参数控制。满足不同需求结果
function findAddNum(arr, num){
  var res = []
  var array = [].concat(arr) // 不改变原数组
  for(var i = 0; i < array.length; i++) {
    var diff = num - array[i]
    var diffIndex  = array.indexOf(diff)
    // 自身不参与重复相加 : 不出现 [5,5]
    if(diffIndex !== -1 && diffIndex !== i) {
      array[diffIndex] = null // 每个数字只参与一次 不会出现[0,10][10,0]
      res.push([i, diffIndex])
    }
  }
  return res.length > 0 ? res : false
}
findAddNum([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10)
// [0, 10],[1, 9],[2, 8],[3, 7], [4, 6]
```
