---
title: 前端复习笔记-2
comments: false
is_update: false
date: 2018-09-02 22:05:36
tags: [笔记]
categories: 笔记
songid:
photos:
---
{% note info %}一边看大佬们的博客一边总结(缓更){% endnote %}

### 词法作用域
> 文章链接 https://github.com/mqyqingfeng/Blog/issues/3  

大佬的博客们,除了文章写的深刻,丰富,其次评论也是很精彩的。通过评论可以加深理解以及拓展更多知识。
这篇文章的重点：
> JavaScript是采用词法作用域的，这就意味着函数的执行依赖于函数定义的时候所产生（而不是函数调用的时候产生的）的变量作用域  

理解这个后下面这些例子也就很快想明白了：
```js
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();
// 结果 为 1 
// 先执行 bar() , 在执行 foo() , foo() 函数定义在最外层, 所以会输出最外层的 value 值
```
<!-- more -->
《JavaScript权威指南》中的例子:
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
// 先执行 checkscope() , 返回 f, 然后执行 f(), f() 定义在 checkscope()内部且其内部有scope 变量, 所以结果 为 local scope
```
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
// 执行 checkscope(), 然后执行 f() , f() 定义在 checkscope()内部且其内部有scope 变量, 所以结果 为 local scope
```
评论中的例子：
```js
var value = 1;
var f = function() { console.log(value) }
function out(f) {
  var value = 2;
  f();
}
out(f)
// 执行 out(f), 然后执行f(), f() 定义的位置在最外层，所以输出结果为 最外层的 1
```
### 变量提升/函数提升
> 原文：https://github.com/mqyqingfeng/Blog/issues/4  

虽然文章讲的是执行上下文栈， 但是评论中涉及很多变量提升和函数提升的探讨，也讲解的非常详细
下面是原文的两段代码：
```js
var foo = function () {
  console.log('foo1');
}
foo();  // foo1

var foo = function () {
  console.log('foo2');
}

foo(); // foo2
```
```js
function foo() {
  console.log('foo1');
}

foo();  // foo2

function foo() {
  console.log('foo2');
}

foo(); // foo2
```
这两段代码涉及到函数提升以及变量提升，将他们改成函数提升/变量提升后的结果为：
```js
// 第一段
var foo;
foo = function() {
  console.log('foo1')
}

foo() // foo1

foo = function() {
  console.log('foo2')
}

foo() //foo2
```
```js
// 第二段
function foo() {
  console.log('foo1')
}
function foo() {
  console.log('foo2')
}
foo() // foo2
foo() // foo2
```
第一段代码是变量提升，第二段代码是函数提升
评论中的例子：
```js
// 函数声明可以提升
foo(); // foo
function foo() {
  console.log('foo');
}
```
```js
// 函数表达式不会提升 ，提升的是 变量 foo
foo(); // TypeError: undefined is not a function
var foo = function() {
  console.log('foo');
}
// 提升后的代码
var foo;
foo() // TypeError: undefined is not a function
foo = function() {
  console.log('foo')
}
```
**个人总结为： 变量申明和函数申明(整体)会被提升，函数表达式提升的是申明变量，函数本身不提升**

另外评论中还有一道关于引用指向问题：
```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };
console.log(a); // {n:2}
console.log(b); // {n:1, x: {n:2}}
```
- 前两步 `a , b` 都指向 同一个对象 `{n: 1}`
- `a.x = a = {n: 2}` 点运算符优先级最高 `a.x` 相当于 `{n:1}.x` , 连等从右往左, `a = {n: 2}` , `{n: 1}.x = {n: 2}` 。`a` 的指向变成了新对象 `{n: 2}`, 对象 `{n: 1}` 增加了 `x` 属性。 `b` 一直指向对象`{n: 1}`

### 数组
> 文章来源：https://juejin.im/post/5aa7d82c6fb9a028c522de43  

在一个数组中 找出里面其中两项相加后的和为num，如果存在就返回两个数的索引位置，否则false(原)
```js
// 原
function fn(num = 0, ary = []) {
  for (let i = 0; i < ary.length; i++) {
    let diff = num - ary[i];
    let diffIndex = ary.indexOf(diff);
    if (diffIndex !== -1) {
      return [i, diffIndex];
    }
  }
  return false;
}

let num = 3;
let arr = [-1, 4, 6, 2];

console.log(fn(num, arr)); // [0, 1]
```
自己对需求做了一点改变：找出数组 `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`,找出相加为 `10`, 如果存在就返回两个数的索引位置的集合，否则false, 每个数字只参与一次组合，并且自身不与自身相加（改）
```js
// 在原本的基础上做了一点小修改
// 待优化： 增加参数控制。满足不同需求结果
function findAddNum(arr, num){
  var res = []
  var array = [].concat(arr) // 不改变原数组
  for(var i = 0; i < array.length; i++) {
    var diff = num - array[i]
    var diffIndex  = array.indexOf(diff)
    // 自身不参与重复相加 : 不出现 [5,5]
    if(diffIndex !== -1 && diffIndex !== i) {
      array[diffIndex] = null // 每个数字只参与一次 不会出现[0,10][10,0]
      res.push([i, diffIndex])
    }
  }
  return res.length > 0 ? res : false
}
findAddNum([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10)
// [0, 10],[1, 9],[2, 8],[3, 7], [4, 6]
```
